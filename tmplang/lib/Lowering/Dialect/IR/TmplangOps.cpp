#include <tmplang/Lowering/Dialect/IR/Ops.h>

#include <llvm/ADT/TypeSwitch.h>
#include <mlir/IR/FunctionImplementation.h>
#include <mlir/IR/OpDefinition.h>
#include <mlir/Support/LogicalResult.h>
#include <tmplang/ADT/LLVM.h>
#include <tmplang/ADT/PrintUtils.h>

using namespace tmplang;

/// Include all autogenerated code for ops
#define GET_OP_CLASSES
#include <tmplang/Lowering/Dialect/IR/TmplangOps.cpp.inc>

void TmplangDialect::registerOps() {
  addOperations<
#define GET_OP_LIST
#include <tmplang/Lowering/Dialect/IR/TmplangOps.cpp.inc>
      >();
}

//===----------------------------------------------------------------------===//
// SubprogramOp
//===----------------------------------------------------------------------===//

StringRef ToString(mlir::SymbolTable::Visibility vis) {
  switch (vis) {
  case mlir::SymbolTable::Visibility::Public:
    return "public";
  case mlir::SymbolTable::Visibility::Private:
    return "private";
  case mlir::SymbolTable::Visibility::Nested:
    return "nested";
  }
  llvm_unreachable("Unexpected visibility");
}

void SubprogramOp::build(mlir::OpBuilder &builder, mlir::OperationState &state,
                         StringRef name, mlir::FunctionType type,
                         mlir::SymbolTable::Visibility symVisibility) {
  mlir::NamedAttribute visibility =
      builder.getNamedAttr(mlir::SymbolTable::getVisibilityAttrName(),
                           builder.getStringAttr(ToString(symVisibility)));

  // FunctionOpInterface provides a convenient `build` method that will populate
  // the state of our SubprogramOp, and create an entry block.
  buildWithEntryBlock(builder, state, name, type, visibility, type.getInputs());
}

mlir::ArrayRef<mlir::Type> SubprogramOp::getArgumentTypes() {
  return getFunctionType().getInputs();
}

mlir::ArrayRef<mlir::Type> SubprogramOp::getResultTypes() {
  return getFunctionType().getResults();
}

mlir::ParseResult SubprogramOp::parse(mlir::OpAsmParser &parser,
                                      mlir::OperationState &result) {
  // Dispatch to the FunctionOpInterface provided utility method that parses the
  // function operation.
  auto buildFuncType =
      [](mlir::Builder &builder, llvm::ArrayRef<mlir::Type> argTypes,
         llvm::ArrayRef<mlir::Type> results,
         mlir::function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return mlir::function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false,
      getFunctionTypeAttrName(result.name), buildFuncType,
      getArgAttrsAttrName(result.name), getResAttrsAttrName(result.name));
}

void SubprogramOp::print(mlir::OpAsmPrinter &p) {
  // Dispatch to the FunctionOpInterface provided utility method that prints the
  // function operation.
  mlir::function_interface_impl::printFunctionOp(
      p, *this, /*isVariadic=*/false, getFunctionTypeAttrName(),
      getArgAttrsAttrName(), getResAttrsAttrName());
}

//===----------------------------------------------------------------------===//
// ReturnOp
//===----------------------------------------------------------------------===//
mlir::LogicalResult ReturnOp::verify() {
  // We know that the parent operation is a function, because of the 'HasParent'
  // trait attached to the operation definition.
  auto function = cast<SubprogramOp>((*this)->getParentOp());

  /// ReturnOps can only have a single optional operand.
  if (getNumOperands() > 1) {
    return emitOpError() << "expects at most 1 return operand";
  }

  // The operand number and types must match the function signature.
  const auto &results = function.getFunctionType().getResults();
  if (getNumOperands() != results.size()) {
    return emitOpError() << "does not return the same number of values ("
                         << getNumOperands() << ") as the enclosing function ("
                         << results.size() << ")";
  }

  // If the operation does not have an input, we are done.
  if (!hasOperand()) {
    return mlir::success();
  }

  auto inputType = *operand_type_begin();
  auto resultType = results.front();

  // Check that the result type of the function matches the operand type.
  if (inputType != resultType) {
    return emitError() << "type of return operand (" << inputType
                       << ") doesn't match function result type (" << resultType
                       << ")";
  }

  return mlir::success();
}

//===----------------------------------------------------------------------===//
// ConstantOp
//===----------------------------------------------------------------------===//
mlir::ParseResult ConstantOp::parse(mlir::OpAsmParser &parser,
                                    mlir::OperationState &result) {
  mlir::Attribute attr;
  mlir::Type type;
  if (parser.parseAttribute(attr) || parser.parseArrow() ||
      parser.parseType(type)) {
    return mlir::failure();
  }

  result.addAttribute("value", attr);
  result.addTypes(type);

  return mlir::success();
}

void ConstantOp::print(mlir::OpAsmPrinter &p) {
  p << ' ';

  llvm::TypeSwitch<mlir::Attribute>(getValue())
      .Case<mlir::ArrayAttr>([&](mlir::ArrayAttr ty) {
        p << '[';
        printInterleaved(
            ty.getValue(), [&](mlir::Attribute ty) { p << ty; }, p.getStream());
        p << ']';
      })
      .Case<mlir::IntegerAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(getValueAttr()); })
      .Case<mlir::FloatAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(getValueAttr()); })
      .Default([](mlir::Attribute) { llvm_unreachable(""); });

  p << " -> ";
  p.printType(getType());
}

static mlir::ParseResult
ParseAggregateOrUnionAccess(mlir::OpAsmParser &parser,
                            mlir::OperationState &result,
                            StringRef attributeIdx) {
  mlir::OpAsmParser::UnresolvedOperand unresolvedOp;
  int64_t idx;
  mlir::Type inputTy;
  mlir::Type accessTy;

  const bool parsingResult =
      parser.parseLParen() || parser.parseOperand(unresolvedOp) ||
      parser.parseRParen() || parser.parseComma() || parser.parseInteger(idx) ||
      parser.parseColonType(inputTy) || parser.parseArrow() ||
      parser.parseType(accessTy);
  if (parsingResult) {
    return mlir::failure();
  }

  llvm::SmallVector<mlir::Value, 1> val;
  if (parser.resolveOperand(unresolvedOp, inputTy, val)) {
    return mlir::failure();
  }
  assert(val.size() == 1);

  result.addAttribute(attributeIdx, parser.getBuilder().getIndexAttr(idx));
  result.addOperands(val.back());
  result.addTypes(accessTy);

  return mlir::success();
}

mlir::ParseResult AggregateDataAccessOp::parse(mlir::OpAsmParser &parser,
                                               mlir::OperationState &result) {
  // Sample of syntax:
  // tmplang.aggregateDataAccess(%0), 0 : (!tmplang<data "A"{i32, i32}>) -> i32
  return ParseAggregateOrUnionAccess(parser, result, "idx");
}

static void PrintAggregateOrUnionAccess(mlir::OpAsmPrinter &p, mlir::Value op, mlir::Value result, llvm::APInt idx) {
  p << '(' << op << "), " << idx << " : "
    << op.getType() << " -> " << result.getType();
}

void AggregateDataAccessOp::print(mlir::OpAsmPrinter &p) {
  PrintAggregateOrUnionAccess(p, getOperand(), getResult(), getIdx());
}

mlir::ParseResult MatchOp::parse(mlir::OpAsmParser &parser,
                                 mlir::OperationState &result) {
  // Sample of syntax:
  // tmplang.aggregateDataAccess(%0), 0 : (!tmplang<data "A"{i32, i32}>) -> i32

  mlir::OpAsmParser::UnresolvedOperand unresolvedOp;
  mlir::Type inputTy;
  mlir::Type resultTy;
  mlir::Region &region = *result.addRegion();

  const bool parsingResult =
      parser.parseLParen() || parser.parseOperand(unresolvedOp) ||
      parser.parseRParen() || parser.parseColonType(inputTy) ||
      parser.parseArrow() || parser.parseType(resultTy) ||
      parser.parseRegion(region);
  if (parsingResult) {
    return mlir::failure();
  }

  llvm::SmallVector<mlir::Value, 1> val;
  if (parser.resolveOperand(unresolvedOp, inputTy, val)) {
    return mlir::failure();
  }
  assert(val.size() == 1);

  result.addOperands(val.back());
  result.addTypes(resultTy);

  return mlir::success();
}

mlir::ParseResult UnionAccess::parse(mlir::OpAsmParser &parser,
                                     mlir::OperationState &result) {
  // Sample of syntax:
  // tmplang.unionAccess(%0), 0 : !tmplang<Union "MyUnion2"{ "firstAlternative"{!tmplang<Union "MyUnion"{ "one"{i32},  "two"{i32}}>},  "secondAlternative"{i32, tuple<i32, i32>}}>
  //   -> !tmplang<data "firstAlternative"{!tmplang<Union "MyUnion"{ "one"{i32},  "two"{i32}}>}>
  return ParseAggregateOrUnionAccess(parser, result, "alternativeIdx");
}

void UnionAccess::print(mlir::OpAsmPrinter &p) {
  PrintAggregateOrUnionAccess(p, getOperand(), getResult(), getAlternativeIdx());
}

void MatchOp::print(mlir::OpAsmPrinter &p) {
  p << '(' << getOperand() << ") : " << getInput().getType() << " -> "
    << getResult().getType() << ' ';
  p.printRegion(getBody());
}

mlir::LogicalResult MatchYieldOp::verify() {
  auto matchOp = cast<MatchOp>((*this)->getParentOp());

  /// ReturnOps can only have a single optional operand.
  if (getNumOperands() > 1) {
    return emitOpError() << "expects at most 1 yield operand";
  }

  // If the operation does not have an input, we are done.
  if (!hasOperand()) {
    return mlir::success();
  }

  auto matchOpResultTy = this->getResults()[0].getType();
  auto yieldResultTy = matchOp.getResult().getType();

  // Check that the result type of the function matches the operand type.
  if (matchOpResultTy != yieldResultTy) {
    return emitError() << "type of match_yield operand (" << matchOpResultTy
                       << ") doesn't match match result type (" << yieldResultTy
                       << ")";
  }

  return mlir::success();
}
