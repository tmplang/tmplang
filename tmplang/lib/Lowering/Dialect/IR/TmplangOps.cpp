#include <tmplang/Lowering/Dialect/IR/Ops.h>

#include <llvm/ADT/TypeSwitch.h>
#include <mlir/IR/FunctionImplementation.h>
#include <mlir/IR/OpDefinition.h>
#include <mlir/Support/LogicalResult.h>
#include <tmplang/ADT/LLVM.h>
#include <tmplang/ADT/PrintUtils.h>

using namespace tmplang;

/// Include all autogenerated code for ops
#define GET_OP_CLASSES
#include <tmplang/Lowering/Dialect/IR/TmplangOps.cpp.inc>

void TmplangDialect::registerOps() {
  addOperations<
#define GET_OP_LIST
#include <tmplang/Lowering/Dialect/IR/TmplangOps.cpp.inc>
      >();
}

//===----------------------------------------------------------------------===//
// SubprogramOp
//===----------------------------------------------------------------------===//

StringRef ToString(mlir::SymbolTable::Visibility vis) {
  switch (vis) {
  case mlir::SymbolTable::Visibility::Public:
    return "public";
  case mlir::SymbolTable::Visibility::Private:
    return "private";
  case mlir::SymbolTable::Visibility::Nested:
    return "nested";
  }
  llvm_unreachable("Unexpected visibility");
}

void SubprogramOp::build(mlir::OpBuilder &builder, mlir::OperationState &state,
                         StringRef name, mlir::FunctionType type,
                         mlir::SymbolTable::Visibility symVisibility) {
  mlir::NamedAttribute visibility =
      builder.getNamedAttr(mlir::SymbolTable::getVisibilityAttrName(),
                           builder.getStringAttr(ToString(symVisibility)));

  // FunctionOpInterface provides a convenient `build` method that will populate
  // the state of our SubprogramOp, and create an entry block.
  buildWithEntryBlock(builder, state, name, type, visibility, type.getInputs());
}

mlir::FunctionType SubprogramOp::getFunctionType() { return function_type(); }

mlir::ArrayRef<mlir::Type> SubprogramOp::getArgumentTypes() {
  return getFunctionType().getInputs();
}

mlir::ArrayRef<mlir::Type> SubprogramOp::getResultTypes() {
  return getFunctionType().getResults();
}

mlir::ParseResult SubprogramOp::parse(mlir::OpAsmParser &parser,
                                mlir::OperationState &result) {
  // Dispatch to the FunctionOpInterface provided utility method that parses the
  // function operation.
  auto buildFuncType =
      [](mlir::Builder &builder, llvm::ArrayRef<mlir::Type> argTypes,
         llvm::ArrayRef<mlir::Type> results,
         mlir::function_interface_impl::VariadicFlag,
         std::string &) { return builder.getFunctionType(argTypes, results); };

  return mlir::function_interface_impl::parseFunctionOp(
      parser, result, /*allowVariadic=*/false, buildFuncType);
}

void SubprogramOp::print(mlir::OpAsmPrinter &p) {
  // Dispatch to the FunctionOpInterface provided utility method that prints the
  // function operation.
  mlir::function_interface_impl::printFunctionOp(p, *this,
                                                 /*isVariadic=*/false);
}

//===----------------------------------------------------------------------===//
// ReturnOp
//===----------------------------------------------------------------------===//
mlir::LogicalResult ReturnOp::verify() {
  // We know that the parent operation is a function, because of the 'HasParent'
  // trait attached to the operation definition.
  auto function = cast<SubprogramOp>((*this)->getParentOp());

  /// ReturnOps can only have a single optional operand.
  if (getNumOperands() > 1) {
    return emitOpError() << "expects at most 1 return operand";
  }

  // The operand number and types must match the function signature.
  const auto &results = function.getFunctionType().getResults();
  if (getNumOperands() != results.size()) {
    return emitOpError() << "does not return the same number of values ("
                         << getNumOperands() << ") as the enclosing function ("
                         << results.size() << ")";
  }

  // If the operation does not have an input, we are done.
  if (!hasOperand()) {
    return mlir::success();
  }

  auto inputType = *operand_type_begin();
  auto resultType = results.front();

  // Check that the result type of the function matches the operand type.
  if (inputType != resultType) {
    return emitError() << "type of return operand (" << inputType
                       << ") doesn't match function result type (" << resultType
                       << ")";
  }

  return mlir::success();
}

//===----------------------------------------------------------------------===//
// ConstantOp
//===----------------------------------------------------------------------===//
mlir::ParseResult ConstantOp::parse(mlir::OpAsmParser &parser,
                                    mlir::OperationState &result) {
  mlir::Attribute attr;
  mlir::Type type;
  if (parser.parseAttribute(attr) || parser.parseArrow() ||
      parser.parseType(type)) {
    return mlir::failure();
  }

  result.addAttribute("value", attr);
  result.addTypes(type);

  return mlir::success();
}

void ConstantOp::print(mlir::OpAsmPrinter &p) {
  p << ' ';

  llvm::TypeSwitch<mlir::Attribute>(value())
      .Case<mlir::ArrayAttr>([&](mlir::ArrayAttr ty) {
        p << '[';
        printInterleaved(
            ty.getValue(), [&](mlir::Attribute ty) { p << ty; }, p.getStream());
        p << ']';
      })
      .Case<mlir::IntegerAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(valueAttr()); })
      .Case<mlir::FloatAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(valueAttr()); })
      .Default([](mlir::Attribute) { llvm_unreachable(""); });

  p << " -> ";
  p.printType(getType());
}
