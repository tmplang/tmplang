#include <tmplang/Lowering/Dialect/HIR/Ops.h>

#include <llvm/ADT/TypeSwitch.h>
#include <mlir/IR/FunctionImplementation.h>
#include <mlir/IR/OpDefinition.h>
#include <mlir/Support/LogicalResult.h>
#include <tmplang/ADT/LLVM.h>
#include <tmplang/ADT/PrintUtils.h>

using namespace tmplang;

/// Include all autogenerated code for ops
#define GET_OP_CLASSES
#include <tmplang/Lowering/Dialect/HIR/TmplangHIROps.cpp.inc>

void TmplangHIRDialect::registerOps() {
  addOperations<
#define GET_OP_LIST
#include <tmplang/Lowering/Dialect/HIR/TmplangHIROps.cpp.inc>
      >();
}

//===----------------------------------------------------------------------===//
// SubprogramOp
//===----------------------------------------------------------------------===//

StringRef ToString(mlir::SymbolTable::Visibility vis) {
  switch (vis) {
  case mlir::SymbolTable::Visibility::Public:
    return "public";
  case mlir::SymbolTable::Visibility::Private:
    return "private";
  case mlir::SymbolTable::Visibility::Nested:
    return "nested";
  }
  llvm_unreachable("Unexpected visibility");
}

mlir::ParseResult SubprogramOp::parse(mlir::OpAsmParser &parser,
                                      mlir::OperationState &result) {
  // Sample of syntax:
  llvm_unreachable("Unimplemented");
  return mlir::success();
}

void SubprogramOp::print(mlir::OpAsmPrinter &p) {
  p << ' ' << getSymbol() << ' ';
  p.printRegion(getRegion(), /*printEntryBlockArgs=*/false,
                /*printBlockTerminators=*/false,
                /*printEmptyBlock=*/false);
}

mlir::ArrayRef<mlir::Type> SubprogramOp::getArgumentTypes() {
  return getSymbol()
      .getType()
      .getValue()
      .cast<mlir::FunctionType>()
      .getInputs();
}

mlir::ArrayRef<mlir::Type> SubprogramOp::getResultTypes() {
  return getSymbol()
      .getType()
      .getValue()
      .cast<mlir::FunctionType>()
      .getResults();
}

//===----------------------------------------------------------------------===//
// ConstantOp
//===----------------------------------------------------------------------===//
mlir::ParseResult ConstantOp::parse(mlir::OpAsmParser &parser,
                                    mlir::OperationState &result) {
  mlir::Attribute attr;
  mlir::Type type;
  if (parser.parseAttribute(attr) || parser.parseArrow() ||
      parser.parseType(type)) {
    return mlir::failure();
  }

  result.addAttribute("value", attr);
  result.addTypes(type);

  return mlir::success();
}

void ConstantOp::print(mlir::OpAsmPrinter &p) {
  p << ' ';

  llvm::TypeSwitch<mlir::Attribute>(getValue())
      .Case<mlir::ArrayAttr>([&](mlir::ArrayAttr ty) {
        p << '[';
        printInterleaved(
            ty.getValue(), [&](mlir::Attribute ty) { p << ty; }, p.getStream());
        p << ']';
      })
      .Case<mlir::IntegerAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(getValueAttr()); })
      .Case<mlir::FloatAttr>(
          [&](mlir::Attribute) { p.printAttributeWithoutType(getValueAttr()); })
      .Default([](mlir::Attribute) { llvm_unreachable(""); });

  p << " -> ";
  p.printType(getType());
}

mlir::ParseResult MatchOp::parse(mlir::OpAsmParser &parser,
                                 mlir::OperationState &result) {
  // Sample of syntax:
  // tmplang.aggregateDataAccess(%0), 0 : (!tmplang<data "A"{i32, i32}>) -> i32

  mlir::OpAsmParser::UnresolvedOperand unresolvedOp;
  mlir::Type inputTy;
  mlir::Type resultTy;
  mlir::Region &region = *result.addRegion();

  const bool parsingResult =
      parser.parseLParen() || parser.parseOperand(unresolvedOp) ||
      parser.parseRParen() || parser.parseColonType(inputTy) ||
      parser.parseArrow() || parser.parseType(resultTy) ||
      parser.parseRegion(region);
  if (parsingResult) {
    return mlir::failure();
  }

  llvm::SmallVector<mlir::Value, 1> val;
  if (parser.resolveOperand(unresolvedOp, inputTy, val)) {
    return mlir::failure();
  }
  assert(val.size() == 1);

  result.addOperands(val.back());
  result.addTypes(resultTy);

  return mlir::success();
}

void MatchOp::print(mlir::OpAsmPrinter &p) {
  p << '(' << getOperand() << ") : " << getInput().getType() << " -> "
    << getResult().getType() << ' ';
  p.printRegion(getBody());
}

mlir::LogicalResult MatchYieldOp::verify() {
  auto matchOp = cast<MatchOp>((*this)->getParentOp());

  /// ReturnOps can only have a single optional operand.
  if (getNumOperands() > 1) {
    return emitOpError() << "expects at most 1 yield operand";
  }

  // If the operation does not have an input, we are done.
  if (!hasOperand()) {
    return mlir::success();
  }

  auto matchOpResultTy = this->getResults()[0].getType();
  auto yieldResultTy = matchOp.getResult().getType();

  // Check that the result type of the function matches the operand type.
  if (matchOpResultTy != yieldResultTy) {
    return emitError() << "type of match_yield operand (" << matchOpResultTy
                       << ") doesn't match match result type (" << yieldResultTy
                       << ")";
  }

  return mlir::success();
}
